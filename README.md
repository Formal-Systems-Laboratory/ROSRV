# ROSRV Overview

[ROSRV](http://fsl.cs.illinois.edu/ROSRV) is a runtime verification framework 
for the [Robot Operating System (ROS)](http://www.ros.org/). ROS is an 
open-source framework for robot software development, providing operating 
system-like functionality on a heterogeneous computer cluster. With the wide 
adoption of ROS, its safety and security are becoming an important problem. 

ROSRV integrates seamlessly with ROS. Its two purposes are (1) monitoring 
safety properties and (2) enforcing security policies. Its core is a runtime 
monitoring infrastructure that intercepts, observes and optionally modifies 
messages passing through the system, to check system's runtime behavior against 
user-defined safety properties and perform desired actions. For automatic 
monitor generation out of formal specifications, ROSRV depends on 
[ROSMOP](http://fsl.cs.illinois.edu/index.php/ROSMOP). ROSRV regulates system 
state and execution of commands by enforcing a user-defined access control 
policy to address security concerns.

## Installation

If you are using ROSRV as part of the AA-EXACT docker image it should
already have been built.
You can rebuild after code changes by running `./Test`.

For instructions on installing from scratch, please refer to [INSTALL.md](INSTALL.md).

## Testing

Run `./Test`. This script runs a series of tests, after
(re)building ROSRV and test monitors if necessary.
Any arguments are passed through to `pytest`.

## Usage

The script `bin/rosrv` will generate a monitor exectuable from
a monitor specification. The executable is added to the rvmonitor
ROS package so that ROS tools such as `roslaunch` can find it.
(The executable file can be found in `devel/rvmonitor/lib`).

```rosrv SPEC.rv -o MONITORNAME```

### Monitors

A monitor generated by the rosrv script can be run with

```rosrun rvmonitor <monitorname>```

The monitors are special ros nodes that inspect
all data transmitted on topics specified in their spec files.
For a topic of interest, a monitor node listens
to incoming messages on `rv/monitored/<topic>`
(topic prefixed with /rv/monitered) and publishes on `<topic>`.
All prexisting nodes are expected to publish to
`/rv/monitered/<topic>` and listen on `<topic>`.
This restriction forces all communication on a topic to
always pass through the monitor, allowing it to publish
 safe messages in case of property violations.

This can be arranged by explicitly adding the monitors
to the roslaunch file of your ROS system and remapping
the outputs of existing nodes, or can be transparently
arranged by using `rvmaster`.

### RVMaster

`rvmaster` is a proxy for `roscore` that transparently
inserts monitors into a ROS system, as an alternative to
adding them explicitly as described above.

To use it, run roscore at a location different from
`ROS_MASTER_URI` your ros system will run with,
put the address of roscore in the environment variable
`REAL_MASTER_URI`, and then run rvmaster passing
the list of topics to be monitored, as

```rvmaster [--monitor-topic TOPIC]*```

and start all the monitor nodes before launching your
ROS system.

The rvmaster process recognizes monitor nodes and adjusts lists
of peer addresses so that ordinary nodes publishing to a monitored
topic send their messages only to the monitor, and ordinary nodes
subscring to a monitored topic receive messages only from the monitor
output.

RVMaster also has some access control features that can restrict which
hostnames may access which topics. This is described in
[docs/Usage.md](docs/Usage.md).
