# Differential Dynamic Logic Monitoring Overview

## Overview

ROSRV and RV-Monitor support runtime monitoring of formulas described in
Differential Dynamic Logic (DL) \[1\]. We use the following RV-Monitor
spec as a running example to describe the tool’s architecture and usage.

``` cpp
#include <rv/dl.h>

testDlWatertankSpec() {

    void pre_check_actions() {
    monitorState.currState.c = 0;
    }
    void post_check_actions(bool verdict) {
    if(!verdict)
        monitorState.currState.f = 0.0;
    }

    void fallback(marti_common_msgs::Float32Stamped& message)
    {
    monitorState.currState.f = 0.0;
    message.value = 0.0;
    }

    void initializeParams()
    {
    monitorState.params.m = 1.0;
    monitorState.params.ep = 5.0;
    }


    event current_level(float l) /level_sensor std_msgs/Float32  '{data:l}'
    {
    update_l(static_cast<long double>(l));
    }

    event flow_controller_input(float f, ros::Time cTime) /flow_control_cmd marti_common_msgs/Float32Stamped
                        '{value:f, header:{stamp:cTime}}'
    {
    update_f(static_cast<long double>(f));
    update_c(static_cast<long double>(cTime.toSec()));

    if(!check_violation( &rosmop_generated::testDlWatertankSpec::pre_check_actions
               , &rosmop_generated::testDlWatertankSpec::post_check_actions) ) {
        fallback(message);
    }
    }

    dL :
    Functions.
      R m.
      R ep.
    End.

    ProgramVariables.
      R f.
      R l.
      R c.
    End.

    Problem.
         (0 <= l & l <= m & 0 < ep)
      -> [
          { f :=*;
        ?-1 <= f & f <= (m-l)/ep;
        c := 0;
        { l' = f, c' = 1 & 0 <= l & c <= ep }
          }*
         ](0 <= l & l <= m)
    End.

    @violation {}
}
```

The dL-formula of interest is expressed using the `dL:` tag. In our
simple example, the formula is a simple water-tank model described in
detail in \[2\].

## Interaction with ModelPlex

We depend on ModelPlex for generation of monitoring conditions. We use
KeYmaeraX \[3\] (version 4.7.2) to generate C code to detect violations.
However, the generated C code cannot be directly employed to detect
violations in a ros based system. The following sections describe how
ROSRV uses said synthesized code to monitor ROS based systems.

## Binding Ros Message Data to Logical Variables

C code generated by KeYmaeraX has the form

``` cpp
    typedef struct parameters {
      long double ep;
      ...
    } parameters;

    typedef struct state {
      long double c;
      long double f;
      ...
    } state;

    bool monitorSatisfied(state pre, state curr, const parameters* const params) {
        ...
    }
```

where structs `parameters` and `state` contain fields corresponding to
the logical formula. For instance, in the `water tank` example, field
`long double f` corresponds to the program variable `R f` of the
dl-formula. ROSRV uses patterns to extract relevant information from
messages and `binds` them to corresponding logical variables. For
instance, in the water tank specification, the following event

``` cpp

    event flow_controller_input(float f, ros::Time cTime)
            /flow_control_cmd
            marti_common_msgs/Float32Stamped
            '{value:f, header:{stamp:cTime}}'
    {
    update_f(static_cast<long double>(f));
    update_c(static_cast<long double>(cTime.toSec()));

    if(!check_violation( &rosmop_generated::testDlWatertankSpec::pre_check_actions
               , &rosmop_generated::testDlWatertankSpec::post_check_actions) ) {
        fallback(message);
    }
    }
```

A ROSRV event has the form

``` cpp
    event <EVENT-NAME>( [EVENT-PARAMETERS] )
            <ROS-CHANNEL> <EVENT-TYPE> <BINDINGS-PATTERN>
    {
        <EVENT-BODY>
    }
```

Thus event `flow_controller_input` synthesizes ros code that -

  - Listens on channel `flow_control_cmd` for messages of type
    `matri_common_msgs/Float32Stamped`.
  - On receiving messages of aforementioned type, extracts the `data`
    and `stamp` part of the message, which can referred to as `f` and
    `cTime` in the body of the event.
  - The functions `update_f` and `update_c` correspond to RV-Monitor
    synthesized code, which essentially takes care of `binding` the
    event parameters to relevant fields in the modelPlex generated
    `state`.
  - `check_violation` is responsible for making a call to the
    `monitorSatisfied` part of the modelPlex generated code.
    `check_violation` also accepts as input function pointers to carry
    out any pre/post check tasks.
  - In this particular instance, when violation is detected, a
    `fallback` function is called. However, `ROSRV` allows C++ code in
    the spec, hence any arbitrary fallback mechanism can be implemented.

#### Synchronization Issues

In order to detect violations using `ModelPlex` the state structs must
be properly `populated` before a call to `monitorSatisfied` is made.
However, in the ROS spec, `check_violation` only makes a call to
`monitorSatisfied` if it has successive completely populated states. In
order to ensure the structs are properly populated, ROSRV also
synthesizes code that tracks the state of populated fields in the state
via maps. This code is utilized by `check_violation` to ensure that
states are properly populated before calling ModelPlex’s generated
code.\`

<div id="refs" class="references">

<div id="ref-DDl08">

\[1\] A. Platzer, “Differential dynamic logic for hybrid systems.” *J.
Autom. Reas.*, vol. 41, no. 2, pp. 143–189, 2008. 

</div>

<div id="ref-ModelPlex2016">

\[2\] S. Mitsch and A. Platzer, “ModelPlex: Verified runtime validation
of verified cyber-physical system models,” *Formal Methods in System
Design*, vol. 49, no. 1, pp. 33–74, Oct. 2016 \[Online\]. Available:
<https://doi.org/10.1007/s10703-016-0241-z>

</div>

<div id="ref-KeymaeraXUrl">

\[3\] “KeYmaera x: An aXiomatic tactical theorem prover for hybrid
systems.” https://ls.cs.cmu.edu/KeYmaeraX. 

</div>

</div>
