Differential Dynamic Logic Monitoring Overview
===============================================

Overview
--------

ROSRV and RV-Monitor support runtime monitoring of
formulas described in Differential Dynamic Logic (DL) [@DDl08].
We use the following RV-Monitor spec as a running example
to describe the tool's architecture and usage.

```{.cpp}
#include <rv/dl.h>

testDlWatertankSpec() {

    void pre_check_actions() {
	monitorState.currState.c = 0;
    }
    void post_check_actions(bool verdict) {
	if(!verdict)
	    monitorState.currState.f = 0.0;
    }

    void fallback(marti_common_msgs::Float32Stamped& message)
    {
	monitorState.currState.f = 0.0;
	message.value = 0.0;
    }

    void initializeParams()
    {
	monitorState.params.m = 1.0;
	monitorState.params.ep = 5.0;
    }


    event current_level(float l) /level_sensor std_msgs/Float32  '{data:l}'
    {
	update_l(static_cast<long double>(l));
    }

    event flow_controller_input(float f, ros::Time cTime) /flow_control_cmd marti_common_msgs/Float32Stamped
                        '{value:f, header:{stamp:cTime}}'
    {
	update_f(static_cast<long double>(f));
	update_c(static_cast<long double>(cTime.toSec()));

	if(!check_violation( &rosmop_generated::testDlWatertankSpec::pre_check_actions
			   , &rosmop_generated::testDlWatertankSpec::post_check_actions) ) {
	    fallback(message);
	}
    }

    dL :
	Functions.
	  R m.
	  R ep.
	End.

	ProgramVariables.
	  R f.
	  R l.
	  R c.
	End.

	Problem.
	     (0 <= l & l <= m & 0 < ep)
	  -> [
	      { f :=*;
		?-1 <= f & f <= (m-l)/ep;
		c := 0;
		{ l' = f, c' = 1 & 0 <= l & c <= ep }
	      }*
	     ](0 <= l & l <= m)
	End.

    @violation {}
}
```

The dL-formula of interest is expressed using the `dL:` tag.
In our simple example, the formula is a simple water-tank
model described in detail in [@ModelPlex2016].


Interaction with ModelPlex
--------------------------

We depend on ModelPlex for generation of monitoring conditions.
We use KeYmaeraX [@KeymaeraXUrl] (version 4.7.2) to generate
C code to detect violations. However, the generated C code
cannot be directly employed to detect violations in a ros based
system. The following sections describe how ROSRV uses said
synthesized code to monitor ROS based systems.


Binding Ros Message Data to Logical Variables
---------------------------------------------

C code generated by KeYmaeraX has the form

```{.cpp}
    typedef struct parameters {
      long double ep;
      ...
    } parameters;

    typedef struct state {
      long double c;
      long double f;
      ...
    } state;

    bool monitorSatisfied(state pre, state curr, const parameters* const params) {
        ...
    }

```

where structs `parameters` and `state` contain fields corresponding
to the logical formula. For instance, in the `water tank` example,
field `long double f` corresponds to the program variable `R f` of the
dl-formula. ROSRV uses patterns to extract relevant information from messages
and `binds` them to corresponding logical variables. For instance, in the
water tank specification, the following event

```{.cpp}

    event flow_controller_input(float f, ros::Time cTime)
            /flow_control_cmd
            marti_common_msgs/Float32Stamped
            '{value:f, header:{stamp:cTime}}'
    {
	update_f(static_cast<long double>(f));
	update_c(static_cast<long double>(cTime.toSec()));

	if(!check_violation( &rosmop_generated::testDlWatertankSpec::pre_check_actions
			   , &rosmop_generated::testDlWatertankSpec::post_check_actions) ) {
	    fallback(message);
	}
    }

```

A ROSRV event  has the form

```{.cpp}
    event <EVENT-NAME>( [EVENT-PARAMETERS] )
            <ROS-CHANNEL> <EVENT-TYPE> <BINDINGS-PATTERN>
    {
        <EVENT-BODY>
    }
```

Thus event `flow_controller_input` synthesizes ros code that -

 - Listens on channel `flow_control_cmd` for messages of type
   `matri_common_msgs/Float32Stamped`.
 - On receiving messages of aforementioned type, extracts
   the `data` and `stamp` part of the message, which can referred
   to as `f` and `cTime` in the body of the event.
 - The functions `update_f` and `update_c` correspond to RV-Monitor synthesized
   code, which essentially takes care of `binding` the event parameters to
   relevant fields in the modelPlex generated `state`.
 - `check_violation` is responsible for making a call to the
   `monitorSatisfied` part of the modelPlex generated code.
   `check_violation` also accepts as input function pointers to
   carry out any pre/post check tasks.
 - In this particular instance, when  violation is detected,
   a `fallback` function is called. However,
   `ROSRV` allows C++ code in the spec, hence
   any arbitrary fallback mechanism can be implemented.


#### Synchronization Issues

In order to detect violations using `ModelPlex` the
state structs must be properly `populated` before
a call to `monitorSatisfied` is made. However,
in the ROS spec, `check_violation` only makes
a call to `monitorSatisfied` if it has successive
completely populated states. In order to ensure
the structs are properly populated, ROSRV also synthesizes
code that tracks the state of populated fields in the state
via maps. This code is utilized by `check_violation` to
ensure that states are properly populated before
calling ModelPlex's  generated code.`

